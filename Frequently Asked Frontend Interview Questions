## Most Frequently Asked Frontend Interview Question ##


## HTML ##


1. What is HTML?
Ans = HTML stand for HyperText Markup Language. Its purpose is to describe the structure of web pages using elements(tags) 
      like heading, paragraphs, links and button etc. Every website you see today is built on HTML as its foundation. 
      HTML was developed by Tim Berners-Lee in 1990 at CERN as the standard language to structure web pages. 

2. What does DOCTYPE mean in HTML?
Ans = DOCTYPE stands for Document Type Declaration. It tells the browser which version of HTML the page is written in so the browser knows
      how to interpret and render the page correctly. It is not an Html tag it is just an instruction at the very top of the HTML  file.
      Without DOCTYPE, browsers may switch to “quirks mode”, where they try to guess how to display the page (often incorrectly).
      With DOCTYPE, browsers use “standards mode”, following proper HTML rules.
      This ensures your webpage looks consistent across different browsers.

3. How do you create a hyperlink in HTML?
Ans = A hyperlink is a clickable link that takes you to the another webpage, section or resource. 
      In HTML, hyperlinks are created using the <a> tag (which stands for anchor).
      Example: <a href="#about">Go to About Section</a>
      href defines where the link goes, and the text inside <a> is what users click.
      The target attribute in the <a> tag defines where the linked page will open when the user clicks the hyperlink.
      By default, links open in the same tab/window, but with target you can control the behavior.
      Different value of target attribut are:
      1. _self = same tab.
      2. _blank = new tab.
      3. _parent = parent frame.
      4. _top = full window.

4. What is the purpose of the <head> tag in HTML?
Ans = The <head> tag tells the browser and search engines important information about the page, it contains: Page Title, Character Encoding, 
      link external or internal stylesheets for design, link to javaScript, also contain Meta information about the page inside <meta> tag.

5. Explain the difference between <ol> and <ul> elements.
Ans = <ol>:
      Ordered list.
      Used when sequence matter.
      Default numbering style(can be changed).

      <ul>:
      Unordered list.
      Used when sequence doesn't matter.
      Default bullet style(can be changed).

6. What is the significance of the lang attribute in HTML?
Ans = The lang attribute in HTML specifies the language of the content inside an element(usually the whole page). It is written inside the <html> tag.
      Exmaple: <html lang="en"> Here "en" means English.
      Importance of lang attribute are:
      1. Accessiblity: Screen reader rely on the lang attribute to read the text correctly with the right pronunciation.
      2. Search Engine Optimization: Search engine use the lang attribute to understand the page language, which help in indexing and showing results.
      3. Transalation Tools: Browser and translation services like google translater detect the language more accurately when lang is set.

7. What is the purpose of the <form> element in HTML?
Ans = The <form> element in HTML is used to collect user input.
      It acts like a container that holds input fields (like text boxes, checkboxes, radio buttons, dropdowns, and buttons).
      When the user submits the form, the data is sent to a server or handled by a script for processing.
      Purpose of <form> are:
      1. Collect data from users.
      2. Group input elements together. 
      3. Enable submission = Works with the <button> or <input type="submit"> to send data.
      4. Define how data is sent = Uses the attribute like action, method.

8. How does the target attribute work in HTML forms?
Ans = The target attribute in a <form> element specifies where to display the response after the form is submitted.
      Just like in hyperlinks, it controls whether the result opens in the same tab, a new tab, or a specific frame/iframe.

9. What are semantic HTML elements? Give examples.
Ans = Semantic elements clearly describe their meaning and purpose to both the browser and developers(<header>, <footer> etc).
      They improve: Accessibility, SEO, Code readability.

10. Difference between block, inline, and inline-block elements?
Ans = Block: Takes full width, starts on a new line. Example: <div>, <p>.
      Inline: Take as much as width needed for their content, doesn’t start from a new line. Example: <span>, <a>.
      Inline-block: Behaves like inline but allows setting width/height. Example: <img>.

11. What is the difference between <div> and <span>?
Ans = <div>: Block-level, starts from the new line, used to group larger sections of content.
      <span>: Inline-level, doesn't start from the new line, used to style or mark small parts of text.

12. What are HTML5 new features?
Ans = Key additions:
      Semantic elements: <header>, <footer>, <article>
      Multimedia: <audio>, <video>
      Graphics: <canvas>, <svg>
      APIs: Geolocation, Drag & Drop, Web Storage
      Form enhancements: email, date, required, placeholder.

13. Difference between HTML and XHTML?
Ans = HTML (HyperText Markup Language)
      Introduced: 1991 by Tim Berners‑Lee.
      Flexible rules: Browsers forgive small mistakes (like unclosed tags).
      Case-insensitive: Tags can be uppercase or lowercase.
      Attributes: Quotes around attribute values are optional.
      Goal: Easy to write, more forgiving for developers.

<!-- Valid in HTML -->
<p>Hello World
<br>

    XHTML (Extensible HyperText Markup Language)
    Introduced: January 26, 2000 (XHTML 1.0 by W3C).
    Strict rules: Must follow XML syntax.
    Case-sensitive: Tags must be lowercase.
    Well-formed: Every tag must be properly closed (<br /> instead of <br>).
    Attributes: Values must always be quoted.
    Goal: Cleaner, consistent code and well‑formed documents.

<!-- Required in XHTML -->
<p>Hello World</p>
<br />

14. Difference between id and class?
Ans = (id)
      Unique identifier for a single element.
      Can’t be reused on multiple elements in the same page.
      Used when you want to target one specific element.
      Higher CSS priority.
      Example: <h1 id="main-title">Welcome</h1>

      (class)
      Can be applied to multiple elements.
      Useful for grouping and styling many elements together.
      Often used with CSS and JavaScript for shared behavior.
      Lower CSS priority.
      Example: <p class="highlight">First paragraph</p>

15. Difference between relative, absolute, and fixed URLs?
Ans = Relative URL
      Definition: Points to a file relative to the current page’s location.
      Use: Shorter, depends on where the file is stored.
      Example: If your page is in a folder, and the image is in the same folder, you just say: <img src="logo.png">

      Absolute URL
      Definition: Full path including domain name.
      Use: Always points to the same resource, no matter where the page is.
      Example: This is the full address of something on the internet. <img src="https://example.com/images/logo.png">

      Fixed URL
      Definition: A fixed URL is a link that always points to the same place on a website, no matter where the page is.
      Use: Tied to a specific location, less flexible.
      Example: Starts from the root (home) of the website. <img src="/images/logo.png">

16. What are data-* attributes used for?
Ans = Definition: data-* attributes are custom attributes in HTML used to store extra information about an element without
      affecting the layout and behavior.
      Purpose: They let developers add small bits of data to HTML elements, which can later be accessed with JavaScript.

      Example: <button data-user-id="123">Click</button>
               const btn = document.querySelector("button");
               console.log(btn.dataset.userId);

17. Difference between <script>, <script async>, and <script defer>?
Ans = <script>
      Default behavior: Browser stops loading the page, runs the script immediately, then continues.
      Effect: Can block page rendering if the script is large.

      <script async>
      Behavior: Script loads in the background while the page continue loading.
      Effect: Once Script loads it runs it immediately(may interrupt page rendering).

      <script defer>
      Behavior: Scripts load in the background but waits untill the Html is fully parsed.
      Effect: Script runs after the page is ready.

18. Difference between <link> and @import for CSS?
Ans = (Link)
      where is used: It is used inside the Html.
      Deffination: It is an Html tag that is used to include the external CSS file.
      Behaviour: It loads CSS file while the page loads(faster).
      Support: It is widely supported.
      Best for: Modern Website.

      (@import)
      where is used: It is used inside the CSS file.
      Deffination: A CSS rule used inside the stylesheet to import another CSS file.
      Behavior: CSS loads after the page loads(slower).
      Support: It is less Supported.
      Best for: Rarely used today.

19. What are meta tags in HTML?
Ans = Meta tag in the html gave the metadata about the page. They describe the character encoding, 
      viewport setting, page description and author of the page. Always placed in the <head> element.
      Not visible to user, but important for the SEO, accessiblity, and browser behaviour.

20. Difference between <canvas> and <svg>?
Ans = (Canvas):
      i) Canvas is pixels based. zooming can make it blurry.
      ii) Shapes are not stored as an element.
      iii) Better for the things that change a lot like gaming or animation.
      iv) Not scalable

      (svg):
      i) Svg is vector-based. zooming keeps it sharp.
      ii) Each Shape is an  element in the DOM.
      iii)Better for the static graphics like icons, diagram etc.
      iv) Scalable - Show good at any size.

21. Difference between localStorage, sessionStorage, and cookies?
Ans = localStorage
      Definition: Stores data in the browser permanently (until manually cleared).
      Lifetime: Data stays even after closing the browser or restarting the computer.
      Size limit: Around 5–10 MB (much larger than cookies).
      Use case: Saving user preferences, themes, or app state.

      sessionStorage
      Definition: Stores data only for the current browser tab/session.
      Lifetime: Data is lost when the tab or browser is closed.
      Size limit: Similar to localStorage (~5 MB).
      Use case: Temporary data like form inputs or session‑specific state.

      Cookies
      Definition: Small pieces of data stored in the browser and sent to the server with every request.
      Lifetime: Can be temporary (session cookies) or persistent (with an expiry date).
      Size limit: Much smaller (~4 KB).
      Use case: Authentication, tracking, server communication.

22. What are accessibility (ARIA) attributes? Why important?
Ans = ARIA(Accessible Rich Internet Application) attribute are the extra html attribute that make the   
      website usable for the peaple with disablity. They provide the information to the technologies 
      like (screen readers) about the roles, states and relationships of elements.
      Example = <button aria-label="Button">Click</button>

23. Difference between <section>, <article>, <aside>, and <main>?
Ans = <main>: The main content of the page, Only one <main> per page. 
      <section>: A part of the page that groups the related content.
      <article>: A block of content that can stand alone.
      <aside>: Extra content on the side.

24.  What is the importance of the viewport meta tag in responsive design?
Ans = The viewport meta tag tells the browser how to control the page’s dimensions and scaling on different devices.
      It’s written in HTML like this: <meta name="viewport" content="width=device-width, initial-scale=1.0">
     
      Importance in Responsive Design
      1. Controls Page Width: Without it, mobile browsers assume a default width (usually ~980px) and shrink the page, making text tiny.
         With it, the page width matches the device’s screen width.

      2. Enables Proper Scaling: initial-scale=1.0 ensures the page is displayed at a 1:1 scale (no zoom-out effect).

      3. Supports Media Queries: CSS media queries rely on the viewport size.
         Without the tag, breakpoints may not trigger correctly on mobile devices.

      4. Improves User Experience: Text is readable without zooming.
         Layout adapts naturally to different screen sizes (phones, tablets, desktops).

25. How can you make a website accessible to users with disabilities?
Ans = Not all users can interact with websites in the same way.
      1. Some may have visual disabilities (blindness, low vision, color blindness).
      2. Some may have hearing disabilities (cannot hear audio content).
      3. Some may have motor disabilities (difficulty using a mouse or keyboard).

      Ways to resolve those issues are:
      1. Use semantic HTML: Proper tags (<header>, <nav>, <main>, <footer>) help screen readers understand the structure.
      2. Provide alternative Text: Add alternative value for the image. Also provide captions or transcripts for videos and audio.
         Example: <img src="chart.png" alt="Sales chart showing growth in 2025">
      3. Keyboard Accessibility: Ensure all interactive elements (like: links, buttons, forms etc) can be used with the keyboard (Tab, Enter). 
         Avoid designs that require only mouse actions.
      4. Color and Contrast: Use high contrast between text and background. Don’t rely only on color to convey meaning (e.g., use icons or labels too).
      5. ARIA (Accessible Rich Internet Applications) Attributes: Add ARIA roles and labels to improve screen reader support.
      6. Responsive and Clear Layout: Make sure content is readable on all devices.

26.  Describe the significance of using the rel="preload" attribute.
Ans = The rel="preload" attribute in HTML is used to tell the browser to load important resources early.

      Significance of rel="preload" attribut are:
      1. Faster Page Rendering: Preload ensures critical resources (like fonts, CSS, or scripts) are fetched as soon as possible.
      2. Optimized Resource Loading: Normally, the browser discovers resources while parsing HTML.
         With preload, you explicitly tell the browser: “This file is important, get it now.”
      3. Improves User Experience: Fonts, styles, and scripts load earlier, preventing issues like “flash of unstyled text” (FOUT) or delayed interactivity.
      4. Better Control for Developers: You can prioritize resources that matter most (e.g., hero image, main CSS, key fonts).
         Avoids situations where less important files block important ones.


## CSS ##


1. What is CSS and what does it stand for?
Ans = CSS stands for Cascading Style Sheets. It is a styling language used to describe how HTML elements should look on a webpage.
      While HTML gives the structure, CSS adds the design - (colors, font, layout, spacing, animation and more).

2. Describe the box model in CSS.
Ans = The CSS box model describes how every html element is treated as a rectangular box.
      Component of the box model are:
      1. Content: The actual text, image or other data inside the element.
      2. Padding: The space between the content and border.
      3. Border: The line surrounding padding and content.
      4. Margin: The space outside the border, seperating the element from other elements.

3. Difference between relative, absolute, fixed, and sticky positioning with example?
Ans = Relative: The element stays in the normal document flow, but you can shift it using (top, left, right or bottom).
      Absolute: It removes from the normal flow, and positioned relative to nearest position ancestor.
      Fixed: Position relative to the viewport, Stays fixed on the screen even when scrolling.
      Sticky: Acts relative untill a scroll threshold, then behave like fixed.

4. What is the difference between inline, internal, and external CSS?
Ans = Inline CSS: Written directly inside the html element using the style attribute, affects only that single element,
      It is hard to maintain in large projects Example = <p style="color:red;">Hello</p>

      Internal CSS: Written inside the <style> tag in the <head> of the html file, Affects only that single html page.
      It is not reusable accross multiple pages.
      Example = <style> p{color : red;}  </style>

      External CSS: Written inside the seperate .css file and linked with the html using the <link> tag, Can style multiple
      pages at once, Best for performance and maintainablity. 
      Example = <link rel="stylesheet" href="style.css">

5. Difference between relative units and absolute units (%, em, rem, vw, vh, px)?
Ans = Relative Units: It is responsive units means, they scale with the context(like parent size, root fontsize or viewport).
      Example of units are:
   a) %(percentage): Relative to parent element.
      Example = div { width: 50%; } /* Half of parent’s width */
   b) em: Relative to the parent font size.
      Example = p { font-size: 2em; } /* Twice parent’s font size */
   c) rem: Relative to the root(html) font size.
      Example = p { font-size: 1.5rem; } /* 1.5 × root font size */
   d) vw: Relative to the width of the browser window.
      Example = div { width: 50vw; } /* 50% of viewport width */
   e) vh: Relative to the height of the browser window.
      Example = div { width: 100vh; } /* Full viewport height */

      Absolut Units: Fixed units, that do not change with the context.
      Example of units are:
   a) px(pixels): Smallest unit of measurement on a digital screen they do not scale with the context.
      Example = p { font-size: 16px; } /* Always 16 pixels */

6. What is the difference between Flexbox and CSS Grid? When to use which?
Ans = Flexbox: A one dimensional layout system(works in a row OR column). It was best for aligning the item along a single axis.
      It was used in the Navigation bars, Centering the elements, distributing the even space between the items.

      Grid: A two dimensional layout system(works in rows AND columns). It was best for the complex page layout.
      It was used in the Dashboard, Full web page structure.

7. How can you center an element horizontally and vertically using CSS?
Ans = There are several ways to do it depending on the situation.

1. Flexbox: easiest and modern way
      Example: .container {
        display: flex;
        justify-content: center; /* centers horizontally */
        align-items: center;     /* centers vertically */
        height: 100vh;           /* full viewport height */
      }

2. Grid : easiest and modest way
      Example: .container {
        display: grid;
        place-items: center; /* shorthand for justify-content + align-items */
        height: 100vh;
      }

3. Using Absolute Position + Transform: classic method
      Example: .element {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }

8. Difference between inline vs block elements in terms of CSS?
Ans = Inline Elements: Does not start from the new line. Take as much width that are needed for there content. we can not set
      width/height directly. We can set the padding/margin in inline element but only in the left and right side not in the top/bottom.
      Multiple inline element can sit together side by side. Example are <span>, <a>, <strong>.

      Block Element: Starts fromt the new line. Takes the full width available. we can set the width, height, padding and margin.
      Each bloack element stacks vertically. Example are <div>, <p>, <section>.

9. What is z-index and how does it work?
Ans = z-index: It controls the stacking order of element on a webpage. It only works with the element that have a 
      position(relative, absolute, fixed or sticky). The element that has the higher z-index appears on the top of the element has lower z-index.

10. Explain the concept of CSS Specificity.
Ans = CSS specificity is the set of rules that determines which CSS rule takes priority when multiple style target the same element.
      Specificity is calculated basced on the type of selector:
      Inline > ID > Class, pseudo-classes > Elements and pseduo-elements.

11. Difference between visibility: hidden and display: none?
Ans = (visibility: hidden): Hides the element but still keeps its space in the layout.
      (display: none): Completely removes the element from the layout, and also its space is gone other element is shift to fill the gap.

12. What is the difference between transform, transition, and animation in CSS?
Ans = Transform: It is used to change the shape, size, or position of an element. It show the changes instantly no smooth effect by itself.
      Transition: Create the smooth effect when a property changes from one value to another. It show the changes when the element triggered 
                  (like hover, focus or state change).
      Animation: Allows continuous, complex or repeat the effect using the keyframes. Effects can run automatically or in loop.

13. What are pseudo-classes and pseudo-elements? Examples?
Ans = Pseudo-classes: Define the state of an element(like hover, focus etc). They let you style the element basced on the user interaction or 
      document structure without adding the extra classes.
      Example: a:hover{color: red} //change the link when hover.

      Pseudo-elements: allow you to style the specific part of an element(like the first letter, first line, or content before/after).
      they use the (::) double colon in modern css.
      Example: p::first-line{ color: green; }//style the first line of a paragraph.

14. What are media queries and how do they work?
Ans = Media queries are a css feature that allow the developer to apply the style based on the specific conditions
      (like viewport width, height, orientation or device type). They are the backbone of responsive design, ensuring the website adapt to 
      desktop, tablets and mobile devices seamlessly.
      Syntax Exmaple: @media(condition) { /* CSS rules here */ }

15. Difference between min-width and max-width in responsive design?
Ans = min-width: Styles apply when the screen width is greater than or equal to the specified value. Often used in (Mobile-first design).
      max-width: Styles apply when the screen width is less than or equal to the specified value. Often used in (Desktop-first design).

16. Difference between CSS BEM methodology and normal CSS? 
Ans = Normal CSS
      Definition: Traditional CSS where you write selectors freely (.header, .nav ul li a, etc.).
      Issues:
      Naming collisions (same class names reused across files).
      Harder to maintain in large projects.
      Deeply nested selectors → less readable and harder to override.

      BEM (Block, Element, Modifier)
      Definition: A naming convention for CSS classes that makes styles more structured and predictable.
      Structure:
      Block: Independent component (.button)
      Element: Part of the block (.button__icon)
      Modifier: Variation of block/element (.button--primary)
      Benefits:
      No naming collisions.
      Easier to scale and maintain.
      Clear relationship between components.

17. Explain the purpose of the float property in CSS.
Ans = The float property is used to position an element to the left or right of its container, allowing other content(like text or inline elements) to wrap
      around it. Orignally designed for wrapping text around images but later used for layout before Flexbox and Grid became popular.
      Purpose of float are:
      1. Warpping the text around the image.
      2. Basic layouts before the modern css(grid/ flexbox) were introduced.
      
      Values of the float are:
      1. left: element float to the left, content wrap to right.
      2. right: element float to the right, content wrap to left.
      3. none: default, element stay in normall flow.
      4. inherit: inherits the float value from its parent.

18. Describe the difference between padding and margin.
Ans = Padding:
      Inside the border.
      Space between the content & border.
      Show element background color
      
      Margin:
      Outside the border.
      Space between the element and other elements.
      Background is always transparent.

19. What is a CSS preprocessor, and why might you use one?
Ans = A CSS preprocessor is a tool that extend the basic feature of CSS by allowing you to write code in a more powerfull, structured and reusable way.
      Popular preprocessor include SAAS, LESS and Stylus. You write style in the preprocessor syntax and then it compiles into standard CSS that browsers can understand.
      Features of the preprocessor are: 
      1. Variable: Store values like color, font or size in one place inside the variable.
      2. Nesting: Write CSS in a hierarchical way that mirrors HTML structure.
      3. Mixins: Reusable blocks of CSS code(like function).
      4. Mathematical Operation: Perform calculation directly in CSS exmaple: .box{width : (100% /3); }.

20. What is the "box-sizing" property in CSS?
Ans = The box-sizing property determines how the browser calculates the width and height of an element.
      It decides whether padding and border are included in the element’s total size or added on top of it.
      Values of box-sizing:
      1. content-box(default): Padding and border are added outside the specified width/height.
      2. border-box: Width/height include content + padding + border.
      3. inherit: The element inherits the box-sizing value from its parent.

21. How can you optimize website performance using CSS?
Ans = CSS Optimization Techniques are:
      1. Minify CSS: Remove spaces, comments, and unnecessary characters. Example: Use tools like cssnano or CleanCSS.
      2. Use External Stylesheets: Keep CSS in separate files so browsers can cache them.
      3. Reduce Unused CSS: Remove unused selectors (tools like PurgeCSS help).
      4. Use Shorthand Properties: Example: margin: 10px 20px; instead of writing four separate lines.
      5. Optimize Animations: Use transform and opacity for smoother animations. Avoid costly properties like top, left.
      6. Media Queries Efficiently: Apply responsive styles only when needed, reducing unnecessary rules.

22.  How do you handle browser compatibility issues in CSS?
Ans = Browser compatibility issues happen when different browsers display your CSS differently.
      A property works in Chrome but not in Firefox.
      Layout looks fine on desktop but breaks on mobile Safari.
      Some modern CSS features (like Grid or Flexbox) aren’t supported in older browsers.

      Ways to resolve them are: 
      1. Vendor Prefixes: Some browsers need special prefixes for newer CSS features.
      Example {
        -webkit-transform: rotate(45deg); /* Chrome, Safari */
      }

      2. CSS Reset or Normalize: Browsers have their own default styles. A reset or normalize file makes them consistent.
      Example: * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      3. Feature Detection: Instead of guessing which browser supports what, check directly.
      Example: @supports (display: grid) {
        .container {
          display: grid;
        }
      }

      4. Progressive Enhancement: Start with simple CSS that works everywhere, then add advanced features for modern browsers.
      5. Tools and Testing: Test your site on multiple browsers (Chrome, Firefox, Safari, Edge, mobile).

23. Explain the difference between adaptive and responsive design.
Ans = Responsive Design:
      Fluid and flexible: The layout stretches or shrinks smoothly depending on the screen size.
      One design fits all: You build one layout that adapts continuously.
      Uses relative units like %, em, rem, and media queries.
      Behavior: Content flows and rearranges itself as the screen changes.
      Example: A 3‑column layout on desktop → 2 columns on tablet → 1 column on mobile, all from the same design.

      Adaptive Design:
      Fixed layouts: You create multiple versions of the site for specific screen sizes (like 320px, 768px, 1024px).
      Device detection: The browser chooses the right layout depending on the device.
      Multiple designs: You prepare separate layouts for mobile, tablet, and desktop.
      Behavior: The design doesn’t “stretch”; it switches between versions.
      Example: A mobile site loads one layout, a desktop site loads another.

      Key Differences are:
      1. Flexibility:
      Responsive: One flexible design that adjusts continuously.
      Adaptive: Multiple fixed designs chosen based on device.

      2. Development Effort:
      Responsive: Build once, maintain one design.
      Adaptive: Build and maintain several designs.

      3. User Experience:
      Responsive: Smooth resizing when you change window size.
      Adaptive: Layout “jumps” when switching between breakpoints.

      4. Best Use Case:
      Responsive: Modern sites that need to work on a wide range of devices.
      Adaptive: Sites targeting specific devices or needing very tailored layouts.


## JavaScript ##


1. What is JavaScript?
Ans = JavaScript is a high‑level, dynamic programming language primarily used to make web pages interactive and responsive.
      Key Characteristics of JavaScript
      1. Client-side scripting language: Runs directly in the browser, enabling interactive features without reloading the page.
      2. Versatile: Can update HTML structure, modify CSS styles, and respond to user actions (like clicks, typing, or scrolling).
      3. Cross-platform: Works across all major browsers and operating systems.
      4. Server-side capability: With tools like Node.js, JavaScript can also build backend applications.
      5. Event-driven: Reacts to user input and system events in real time.

2. Difference between var, let, and const?
Ans = var: Function‑scoped (available throughout the function where declared).
      Hoisting: Hoisted to the top of its scope and initialized as undefined.
      Re‑declaration: Allowed (you can declare the same variable multiple times).
      Re‑assignment: Allowed.
 
      let: Block‑scoped (only available inside {} where declared).
      Hoisting: Hoisted but not initialized → Temporal Dead Zone until declared.
      Re‑declaration: Not allowed in the same scope.
      Re‑assignment: Allowed.

      const: Block‑scoped (like let).
      Hoisting: Same as let (Temporal Dead Zone).
      Re‑declaration: Not allowed.
      Re‑assignment: Not allowed (value is constant).

3. What is the difference between == and ===?
Ans:  == (Loosly Equality Operator)
      Definition: Compares two values for equality after type conversion (type coercion).
      Behavior: If the types are different, JavaScript tries to convert them to the same type before comparing.

      === (Strict Equality Operator)
      Definition: Compares two values for equality without type conversion.
      Behavior: Both value and type must match exactly.

4. What is hoisting in JavaScript?
Ans = Hoisting is JavaScript default behavior of moving declarations(not initializations) to the top of their scope(function or global).
      Only the decleration is hoisted, not the assignment.

   1. Variable Hoisting: 
      var: Declaration is hoisted imediately asssigned with the value of undefined.
      let and const: Declaration is hoisted but not initialized. They remain in the special zone called Temporal Dead Zone until the actual delcelaration line.

   2. Function Hoisting:
      Function Declaration: Fully hoisted we can call them before they are defined.
      Function Expression / Arrow Function: Not hoisted.

5. Difference between null, undefined and undeclared?
Ans = undefined:
      Definition: A variable that has been declared but not assigned a value.
      Default behavior: JavaScript automatically assigns undefined to uninitialized variables.
      Example: let a;
               console.log(a); //undefined

      null:
      Definition: An intentional assignment of “no value.”
      Behavior: You explicitly set a variable to null to indicate it should be empty. 
      Example: let a = null;
               console.log(a); //null

      undeclared:
      Defination: A variable that has never been declared in the curent scope.
      Behavior: You trying to access the variable that never deen declared will throws a "ReferenceError".
      Example: console.log(x); //RefernceError: x is not defined

6. What is closure in JavaScript?
Ans = Deffination: A closure is formed when an inner function captures variables from its outer (lexical) scope.
      Even after the outer function returns, the inner function retains access to those variables.
      This happens because JavaScript uses lexical scoping and keeps references to the environment where the function was created.
      Example: function outer(x){
                 let y = 10;
                 function inner(){
                    return x + y;
                  } 
                  return inner;
                 }
      const closure = outer(5);
      console.log(closure()); //15

7. Difference between synchronous and asynchronous JavaScript?
Ans = Synchronous JavaScript
      Definition: Code is executed line by line, in order.
      Behavior: Each statement must finish before the next one starts.
      Blocking: If one task takes time (like a heavy calculation), it blocks everything else.

      Asynchronous JavaScript
      Definition: Code execution can continue without waiting for a task to finish.
      Behavior: Long‑running tasks (like API calls, timers, file reads) run in the background, and results are handled later.
      Non‑Blocking: Other code executes while waiting.

8. Difference between event bubbling and event capturing?
Ans = Event Bubbling:
      Definition: When an event occurs on an element, it first runs the handler on that target element, then on its parent, and continues up the DOM tree.
      Default behavior: Most events in JavaScript use bubbling by default.
      Example:
      <div onclick="alert('DIV clicked')">
        <button onclick="alert('Button clicked')">Click Me</button>
      </div>

      Event Capturing:
      Definition: The opposite of bubbling. The event is first captured by the outermost ancestor and then propagated down to the target element.
      Activation: You must explicitly enable capturing by passing true as the third argument in addEventListener.
      Example:
      div.addEventListener("click", () => alert("DIV clicked"), true);
      button.addEventListener("click", () => alert("Button clicked"), true);     

9. What is the difference between call, apply, and bind methods?  
Ans = call(): Invoked the function immediately, with a specified (this) value and arguments provide individually.
      Example: const user = {
                 name : "bob",
                 greet(){ console.log(`Hello ${this.name}`); }
               }
               const sayhello = user.greet;
               sayhello.call(user); Hello bob

      apply(): Similar to the (call()). Function invoked immediately but the argument are passed as an array.
      Exmaple: function greet(city1, city2){
                      console.log(`Hello, ${this.name} are you from ${city1} or ${city2}?`);
                }
               const user = {name : "bob"}
               greet.apply(user, ["america", "new york"]); //Hello bob are you from america or new york?

      bind(): It is used when you want to fix the (this) context and want to reuse the function later this thing was commonly used in (event handlers).
      Exmaple: function greet(city1){
                  console.log(`Hello, ${this.name} are you from ${city1}?`);
                }
               const user = {name : "bob"};
               const bound = greet.bind(user, "america");
               bound(); //Hello bob are you from america?

10. Difference between shallow copy and deep copy in JS?
Ans = Shallow Copy
      Definition: A shallow copy duplicates only the top‑level properties of an object.
      Nested objects/arrays: They are not cloned — instead, the copy still points to the same reference in memory.
      Effect: If you change something inside a nested object/array in the copy, the original will also change (because they share the same reference).

      Example: // shallow copy
      const obj = {
          name : "bob",
          add : {
              city : "UP"
          }
      }
      const obj1 = Object.assign({}, obj);
      obj1.add.city = "Uttar Pradesh";
      console.log(obj); 
      console.log(obj1);
      //Changes are refleced on both of the object 

      Deep Copy
      Definition: A deep copy duplicates all levels of properties, including nested objects and arrays.
      Nested objects/arrays: They are cloned into new memory locations, not shared with the original.      
      Effect: Changes in the copy do not affect the original, because they no longer share references.

      Example: 
      const obj1 = {
            name : "bob",
            add : { city : "UP" }
      }
      function deepCopy(obj){
    
          if(typeof(obj) !== "object" || obj === null){
              return obj;
          }
    
          let result = Array.isArray(obj)? [] : {};
          let key = Object.keys(obj);
    
          for(let i = 0; i < key.length; i++){ result[key[i]] = deepCopy(obj[key[i]]); }
    
          return result;
      }
      const obj2 = deepCopy(obj1);
      console.log(obj2);

11. What are promises in JavaScript?
Ans = A Promise in JavaScript is an Object that represent the eventual completion and failure of an asynchronous operation
      
      States of a Promise:
      Pending: Initial state, operation not yet completed.
      Fulfilled: Operation completed successfully, returns a value.
      Rejected: Operation failed, returns an error reason.

      Promise Methods:
      .then() → handle success.
      .catch() → handle errors.
      .finally() → run code regardless of success or failure.
      Promise.all() → run multiple promises in parallel, wait for all to finish.
      Promise.race() → returns the result of the first promise that settles.

12. What is the purpose of the async keyword in JavaScript?
Ans = The async keyword is used to declare a asynchronous function. An async function always returns a Promise, even if you return a simple value.
      Inside an async function, you can use the 'await' keyword to pause execution until a Promise resolves.
      Purpose of async are:
      1. Simplifies Asynchronous Code: Instead of chaining .then() with Promises, you can write code that looks synchronous but runs asynchronously.
      2. Automatic Promise Wrapping: Any value returned from an async function is automatically wrapped in a Promise.
      3. Works with await: Lets you pause execution until a Promise resolves, making code easier to read.
      4. Error Handling: You can use try...catch inside async functions to handle errors cleanly.

13. Difference between promise chaining and async/await?
Ans = Promise Chaining: It uses the .then() and .catch() to handle multiple asynchronous operation sequentially. Can became hard to read and manage when 
      many .then() blocks are chained. A single .catch() at the end to handle the error.

      async/await = It is syntactic sugar built on the top of promise that make the asynchronous code look synchronous. Uses the try...catch for error
      handling. Easier to read, write and debug compared to long chain of .then(). 

14.What is the difference between localStorage and sessionStorage?
Ans = LocalStorage vs SessionStorage in JavaScript
      1. Definition
      localStorage: Stores data in the browser with no expiration date. Data persists across tabs, and browser restarts until explicitly cleared.
      sessionStorage: Stores data for the current browser tab session only. Data is lost once the tab or browser is closed.

      2. Scope
      localStorage: Shared across all tabs and windows of the same origin (domain + protocol + port).
      sessionStorage: Unique to each tab/window. Opening the same site in a new tab creates a fresh sessionStorage.

      3. Capacity
      localStorage: Its capacity is ~10MB.
      sessionStorage: Its capacity is around ~5MB.

      4. Use Cases
      localStorage: Saving user preferences (theme, language), Caching data for offline use and
      Persisting login tokens (though not recommended for sensitive data).
      sessionStorage: Temporary form data, Shopping cart data for a single session and State that should reset when the tab closes.

15. Difference between setTimeout and setInterval?
Ans = setTimeout = Runs once after a specified delay, We can clear the timeout using the clearTimeout(id) method.
      setInterval = Runs a function repeatedly at a specified interval, we can clear the interval using the clearInteval(id) method.

16. What is the difference between arrow functions and normal functions?
Ans = Arrow Function: It was introduced in ES6. It was the shorter syntax to write the function. 
      Arrow function do not have their own this. They inherit the this from the lexical scope.
      Cannot be used as a constructor(new keyword won't work).
      Do not have their own arguments object.
      If the function body is a single expression, you don't need to return or {}.
      Example: const add = (a, b) => a + b;

      Normal Function: Have their own this(depend how the function is called).
      Can be used as a constructor with new.
      Have their own argument object.
      Example: function add(a,b){ return a+b; }

17.Difference between for...in and for...of loops?
Ans = for...in: Iterates over the keys (property names) of an object.
      Works on: Objects (and arrays, but not recommended).

      Example: 
      const obj = {name : "bob", age : 30};
      for(let key in obj){console.log(key, obj[key]);}

      for...of: Iterates over the values of an iterable (arrays, strings, Maps, Sets, etc.).
      Works on: Iterables (not plain objects unless you use Object.values() or Object.entries()).

      Example:
      const arr = ["a", "b", "c"];
      for(let value of arr){console.log(value);}

18. What is the difference between DOM and BOM?
Ans = DOM (Document Object Model): A programming interface for HTML documents.
      Purpose: Represents the structure and content of a webpage as a tree of nodes.
      Focus: Deals with document elements (tags, attributes, text).

      BOM (Browser Object Model): A programming interface for the browser itself.
      Purpose: Represents the browser environment outside the page content.
      Focus: Deals with browser features (window, history, location, navigator, screen).

19. Difference between innerHTML and innerText?
Ans = innerHTML: Retrun or set the HTML content inside an element — including the tags and the text between them.
      innerText: Return or set the visible text inside an element, ignoring the html tag.

20. What is the difference between event delegation and event handling?
Ans = Event Handling: Attaching an event listener directly to the element you want to respond to.
      How it works: The listener is bound to that specific element.
      Use case: When you only need to handle events on a few known elements.

      Event Delegation: Attaching a single event listener to a parent element and using "event bubbling" to detect which child triggered the event.
      How it works: Instead of adding listeners to every <li>, you add one listener to the <ul> and use "event.target" to figure out which child triggered it.
      Use case: Efficient when handling events on many dynamic child elements (like items in a list).

21. Difference between ES5 and ES6 features?
Ans = ES5:
      var only
      Normal function
      Modules are not supported
      Async handling are done by the "Callbacks"
      String are written with "Concatenation +"

      ES6:
      Introduce let and const
      Arrow Function
      Modules are introduced
      Async handling are done by the "Promises"
      Introduce template literal

22. What are higher-order functions in JavaScript?
Ans = A function is considered higher‑order if it does one (or both) of the following:
       i  Takes another function as input (argument).
       ii Returns a new function as output.
      This is possible because in JavaScript, functions are first‑class citizens — meaning they can be stored in variables, passed around, 
      and returned just like numbers or strings.

23. What is the difference between JSON and JavaScript objects?
Ans = JSON(JavaScript Object Notation): A text-based data format Mostly used when sending/receiving the data between server and browser.
      Keys and value must be in double quotes.
      Cannot store function and methods.      
      Example {"name" : "bob", "role" : "developer"}

      JavaScript Objects: It is a data Structure in JavaScript. Used to store the key-value pair.
      Keys can be of any data type and write without the quotes.
      Values can be strings, numbers, arrays, other objects, or even functions.
      Exmaple: 
      const person = {
        name: "Varsha",
        age: 25,
        skills: ["JavaScript", "React"],
        greet: function() { console.log("Hello!"); }
      };

24. Difference between mutable and immutable data in JS?
Ans = Mutable Data: Data that can be changed/modified after it is created.
      Examples in JS: Objects, Arrays
      Behavior: If you change a property or element, the original data structure is updated.

      Immutable Data: Data that cannot be changed once created. Any modification creates a new copy.
      Examples: Primitive types → string, number, boolean, null, undefined, symbol, bigint
      Behavior: If you try to change them, a new value is created instead of modifying the original.

25. Difference between map(), forEach(), filter(), and reduce()?
Ans = forEach(): Loops through each element of array and execute the callback.
      Return: Nothing(undefined)
      Example: const arr = [1, 2, 3];
      arr.forEach(num => console.log(num * 2)); // Output: 2, 4, 6

      map(): Creates a new array by transforming each element.
      Return: A new array of same length.
      Example: const arr = [1, 2, 3];
      const doubled = arr.map(num => num * 2);
      console.log(doubled); // [2, 4, 6]

      filter(): Creates a new array with only elements that pass a condition.
      Return: A new array.
      Example: const arr = [1, 2, 3, 4];
      const evens = arr.filter(num => num % 2 === 0);
      console.log(evens); // [2, 4]

      Reduce(): Reduce an array to a single value by applying the function.
      Return: A single value.
      Example: const arr = [1, 2, 3, 4];
      const sum = arr.reduce((acc, num) => acc + num, 0);
      console.log(sum); // 10

26. What is the difference between functional programming and OOP in JS?
Ans = Object‑Oriented Programming (OOP)
      Organizes code around objects and classes (data + behavior together).
      Uses classes and instances.
      Focuses on encapsulation, inheritance, and polymorphism.
      Data is often mutable (object properties can be changed).
      Reusability comes from class hierarchies and inheritance.
      Best for modeling real‑world entities (e.g., User, Car, Order).

      Functional Programming (FP)
      Organizes code around functions and data transformations.
      Uses pure functions (no side effects, same input → same output).
      Focuses on immutability and function composition.
      Data is usually immutable (new copies created instead of modifying).
      Reusability comes from higher‑order functions and composition.
      Best for data processing pipelines (map, filter, reduce).

27. Difference between prototype and __proto__?
Ans = prototype:
      exists on constructor function.
      Used to defines what property/method that should be inherited by all instances created with new.
      used when creating reusable methods for all instances.
      an object property of functions.

      __proto__:
      exists on all objects.
      It is a hidden property that points to the object's prototype.
      used internally to connect objects in the prototype chain.
      a reference (pointer) to another object.
      used internally to connect objects in the prototype chain.

28. What is the difference between class and constructor function in JS?
Ans = class: 
      Classes are syntactic sugar over constructor functions.
      More readable and structured.
      Not hoisted.
      Both require new to create instances. but class throw error if new is missing.
      Methods automatically go to prototype.
      Introduce inheritance using the extends and super.
      Always runs in strict mode. Safer by default.

      constructor:
      Function-based, used to create objects.
      Harder to read in large codebases.
      Hoisted.
      Both require new to create instances.
      Methods added via prototype manually.
      Introducing inheritance is error-prone.
      Not strict by default.

29. Difference between import and require?
Ans = require: 
      It is a older way of importing the modules in JavaScript.
      It loads the modules synchronously(one after another, bloacking).
      Uses (module.exports).
      can be called anywhere in the code.
      Not hoisted, runs when called.

      import:
      It is a modern way.
      It loads the modules asynchronously(non-bloacking).
      Uses (export and export default).
      must be at the top, but support dynamic import() too.
      hoisted to the top automatically.

30. Difference between debouncing and throttling in JavaScript?
Ans = Debouncing:
      Run after user stop triggering the event.
      Debouncing is useful when you only want the action to happen once after a pause, like waiting until typing stops in a search box.
      Debouncing resets the timer every time the event is fired, so the function only runs after event stop fire.
      Best for input fields, resize events.

      Throttling:
      Runs at fixed intervals while event keep firing.
      Throttling is useful when you want the action to happen regularly, like updating scroll position while the user scrolls.
      Throttling ignores extra events during the delay period and only allows the function to run once per set interval.
      Best for Scroll, mouse move, or repeated clicks.

31. What is the difference between REST API and GraphQL in frontend usage?
Ans = REST API:
      It stands for Representation State Transfer. It is a way for frontend and backend to talk to each other using HTTP requests.
      REST API uses many endpoints for different resources.
      REST API decides what data to send back.
      REST API may require multiple requests to get related data.
      REST API uses HTTP methods like GET, POST, PUT, DELETE.
      REST API is easier to cache because endpoints are fixed.
      REST API can return extra or missing data.
      REST API is older and widely supported.

      GraphQL:
      It is a query language for API's created by facebook. It gives the frontend more control over what data it wants.
      GraphQL uses a single endpoint for all requests.
      GraphQL lets the client choose exactly what data it wants.
      GraphQL can fetch everything in one request.
      GraphQL uses queries and mutations.      
      GraphQL caching is more complex.
      GraphQL returning only the requested fields.
      GraphQL is newer and popular in modern frontend frameworks like React.

32. What is the purpose of the "this" keyword in JavaScript?
Ans = The "this" keyword refers to the "object" that is currently executing the function.
      Its value depends on how and where the function is called, not where it is defined.
      Purpose of this are:
      1. Object Context: Inside an object method, this refers to the object itself.
      2. Global Context: In the global scope, this refer to the global object(window in browser.)
      3. Constructor function/ Classes: in a constructor, this refer to the newly created object.
      4. Event Handlers: In DOM event handlers, this usually refers to the element that received the event.
      5. Arrow Function: Arrow function do not have their own this. They inherit this from the surrounding(lexical) scope.

33. Explain the concept of prototypal inheritance in JavaScript.
Ans = Prototypal inheritance is the mechanism in JavaScript by which objects can inherit properties and methods from other objects.
      Every object in JavaScript has an internal link to another object called its prototype.
      If you try to access a property or method that doesn’t exist on the object, JavaScript looks up the chain (the prototype chain) 
      until it finds it or reaches null. Many built-in methods(like toString(), hasOwnProperty()) come from Object.prototype.
      Benefits are:
      1. Code Reuse: Methods defined once can be shared across many objects.
      2. Efficieny: Saves memory since methods are not duplicated for each object.
      3. Flexiblity: Object can be extended dynamically.

34. How do you handle errors in JavaScript?
Ans = Ways to handle the Error in JavaScript are:
      1. Using try...catch: Wrap the code that might throw an error inside a try block. If an error occurs, the catch block runs.
      2. Using finally: The finally block runs always, whether an error occurs or not.
      3. Error Objects: JavaScript errors are represented by the Error object.
      Example:      
      function divideNumbers(a, b){
          try{
              if(b === 0){
                  throw new Error("Division by 0 is not allowed");
              }
              let result = a / b;
              console.log(result);
          }catch(error){
              console.log("Error message", error);
          }finally{
              console.log("Division attempt finished");
          }
      }
      divideNumbers(10, 0);

35. Explain the concept of callback functions?
Ans = A callback function is a function that is passed as an argument to another function, and is executed later. 
      It’s called “callback” because the parent function calls-back the function you provided.
      Example:
      function greet(name, callback) {
        console.log("Hello, " + name);
        callback(); // call the function passed in
      }

      function sayGoodbye() { console.log("Goodbye!"); }

      greet("bob", sayGoodbye); // Hello, bob // Goodbye!

36. What is the event loop in JavaScript?
Ans = The event loop is a mechanism in JavaScript that allows it to perform non-blocking operations despite being single-threaded.
      It continuously checks the call stack and the message queue (or task queue), deciding what code to execute next.
      This is how JavaScript manages asynchronous tasks like timers, promises, and I/O without freezing the page.
      How it works:
      1. Call Stack: Where JavaScript keeps track of function calls. Functions are pushed onto the stack when called, and popped off when they finish.
      2. Web APIs/ Background Tasks: Asynchronous operations (like setTimeout, fetch, DOM events) are handled outside the stack by the browser’s Web APIs.
      3. Callback/Task Queue: Once an async task finishes, its callback is placed in the queue.
      4. Event Loop: The event loop constantly checks:
       - If the call stack is empty → it takes the next callback from the queue and pushes it onto the stack.
       - This ensures async tasks run only after synchronous code finishes.

37. How do you create an object in JavaScript
Ans = There is multiple ways to create object:
      1. Object Literal: It is a quick and simple way to create an object. Best for small, straight forward objects.
      2. Using new Object(): Creates an empty object, then you add properties in it. Less common, but still valid.
      3. Constructor Function: Define a function that acts like a blueprint. Useful when creating multiple similar objects.
      4. Object.create(): Creates a new object with a specified prototype. Useful for prototype inheritance.

38.  How does the typeof operator work in JavaScript?
Ans = The typeof operator returns a string indicating the data type of the operand. It is useful for debugging, type checking and writing flexible code.
      Example: console.log(typeof "Hello"); //"string"

39. How can you optimize website performance using JavaScript?
Ans = JavaScript Optimization Techniques are:

      1. Minify and Bundle JS: Compress code and combine files to reduce HTTP requests.
      2. Defer or Async Loading: Use defer or async in <script> tags so JS doesn’t block HTML rendering. 
      3. Lazy Loading: Load images, videos, or components only when needed.
      4. Reduce DOM Manipulations: Batch updates instead of making multiple changes one by one.
      5. Use Efficient Loops and Algorithms: Optimize logic to avoid unnecessary computations.
      6. Cache Data: Store results locally (e.g., in localStorage or memory) to avoid repeated API calls.
      7. Avoid Memory Leaks: Remove unused event listeners and references.

40.  How do you handle browser compatibility issues in JavaScript?
Ans = Browser compatibility issues happen when JavaScript code works in one browser but not in another.
      Some features (like fetch, Promise, async/await) may not be supported in older browsers.
      Different browsers may handle DOM methods or events differently.
      ES6+ features (like arrow functions, classes, modules) might break in Internet Explorer.

      Ways to resolve those issues:
      1. Feature Detection: Instead of checking which browser is being used, check if the feature exists before using it.
      2. Transpilers (like Babel): Write modern JavaScript (ES6+), and use Babel to convert it into older JavaScript that all browsers understand.
      3. Graceful Fallbacks: If a feature isn’t supported, provide an alternative.
      4. Testing Across Browsers: Always test your site on multiple browsers (Chrome, Firefox, Safari, Edge, mobile).

41. Explain the difference between adaptive and responsive design.
Ans = Responsive Design:
      You create one flexible layout that stretches or shrinks smoothly depending on the screen size.
      Build and maintain ine design.
      Content flows and rearrange itself as the screen size changes.
      Best used for: Modern sites that need to work on a wide range of devices.
      
      Adaptive Design:
      You create multiple version of the site for specific screen size(like 320px, 768x, 1024x).
      Build and maintain several designs.
      The design does not strech it switches between versions.
      Best used for: Sites targeting specific devices or needing very tailored layouts.

42. What is a CSS Framework, and why might you use one?
Ans = A CSS Framework is a collection of pre-written CSS rules, styles, and sometimes JavaScript components that help you build websites faster and more 
      consistently. Instead of writing all the CSS from scratch, you use the framework's ready-made classes and layouts. Ex: Bootstrap, Tailwind CSS etc.
      
      Key pointst that explain why use one:
      1. Faster Development: You don’t need to design every button, form, or grid system yourself. It saves times especially in large projects.
      2. Consistency: Frameworks ensure a uniform look of your site. 
      3. Cross-Browser Compatibility: Frameworks handle quirks between browsers, so your site looks correct everywhere.
      4. Community and Documentation: Popular frameworks have string communities, tutorial, and support. That made them easier to learn and troubleshoot.

43. Explain the concept of a mobile-first approach in web development.
Ans = The mobile‑first approach means you start designing and coding your website for mobile devices first, and then add styles for larger screens 
      (like tablets and desktops). Write the default CSS for the mobile and then add media queries for larger screens.
      Why use Mobile-First:
      1. Most users browse on mobile: so it make sense to priotize mobile experience.
      2. Better performance: mobile sites are lighter, faster and easier to load.
      3. Progressive enhancement: you start with the basics and add more features for bigger devices.

44. How do you prevent the default behavior of an event in JavaScript?
Ans = In JavaScript, some events have default behaviors.
      Examples:Clicking a link (<a>) → browser navigates to another page.
      Submitting a form → page reloads.
      Right‑clicking → context menu opens.
      Sometimes you don’t want these default actions to happen. For example, you might want to handle the form submission with JavaScript instead of 
      letting the browser reload. So in that case You use the (event.preventDefault()) method inside your event handler.
      This tells the browser: “Don’t do the default action, I’ll handle it myself.

45. Explain the purpose of the event.stopPropagation() method.
Ans = In JavaScript, events can bubble up through the DOM.
      Example: If you click a button inside a <div>, the click event first runs on the button, then “bubbles” up to the <div>, then to <body>, and so on.
      Sometimes you don’t want the event to "trigger handlers on parent elements" — you only want it to run on the element itself.
      That’s where (event.stopPropagation() comes in.)
      
      Example: <div id="parent" style="padding:20px; background:lightblue;"> <button id="child">Click Me</button> </div>
      <script>
      document.getElementById("child").addEventListener("click", function(event) { 
      event.stopPropagation(); // stops bubbling 
      alert("Button clicked only!"); });
      </script>

46. What is destructuring assignment in JavaScript?
Ans = Destructuring Assignment is JavaScript is a way to unpack values from arrays or properties from objects into seperate variable in a clean and concise way.
      Example: const number = [10, 20, 30];
      const a = number[0];
      console.log(a); //10

    - Object Destructing Rule: Whne you destructure an object, the variable name must match the property name in the object unless you rename it
      Example: const person = { name: "Varsha", age: 25 }; 
               // Correct: variable names match property names 
               const { name, age } = person; 
              // Rename while destructuring 
              const { name: userName, age: userAge } = person;


## React ##


1. What is the difference between functional and class components?
Ans = Functional Component:
      A plain JavaScript function that returns JSX.
      Use hooks like useState, useEffect for managing the state and side effect.
      Lightweight, faster and easier to test.
      Hooks allow easy reuse of logic across different components.
      easier to test since they are pure functions.
      widely used and recommended in modern React apps.

      Class Component:
      class that extends React.Component and has a render() method.
      Manage the state use this.state and update the state with the this.setState().
      Slightly heavier due to this binding and class overhead.
      reuse is harder, often requires higher-order components or render props.
      more complex due to (this) context.
      legacy approach, still supported but less common in new projects.

2. What are React hooks? Common hooks?
Ans = React Hooks are special functions in React that let you use state and other React features inside functional components 
      without writing class components.
      Commonly Used React Hooks are:
      1. useState: use to manage the state.
      2. useEffect: handles side effects.
      3. useMemo: Memoizes expensive calculations.
      4. useCallback: Memoizes functions to prevent unnecessary re-renders.
      5. useLayoutEffect: Similar to useEffect but runs synchronously after DOM mutations.


3. Difference between useEffect and useLayoutEffect?
Ans = Difference Between useEffect and useLayoutEffect are:

      Execution Timing
      useEffect: Runs after the browser has painted the UI.
      useLayoutEffect: Runs before the browser paints the UI.

      Blocking vs Non‑Blocking
      useEffect: Non‑blocking → the user sees the updated screen immediately, then the effect runs.
      useLayoutEffect: Blocking → delays the paint until the effect finishes.

      Use Cases
      useEffect: Best for side effects like API calls, logging, subscriptions, timers.
      useLayoutEffect: Best for DOM measurements, synchronizing layout, or animations that depend on exact element sizes/positions.

      Performance
      useEffect: More efficient, doesn’t slow down rendering.
      useLayoutEffect: Can hurt performance if heavy work is done, because it blocks paint.

4. What is the difference between controlled and uncontrolled components?
Ans = Difference Between Controlled and Uncontrolled Components in React are:

      Definition
      Controlled Component: The form data is handled by React state.
      Uncontrolled Component: The form data is handled by the DOM itself.

      Data Source
      Controlled: Value of input comes from React state (value={state}).
      Uncontrolled: Value of input comes directly from the DOM (defaultValue or ref).

      State Management
      Controlled: You must use useState (or this.state in class components) to manage input values.
      Uncontrolled: You access values using refs (e.g., inputRef.current.value).

      Updates
      Controlled: Every keystroke updates React state, and React re-renders the component.
      Uncontrolled: The DOM updates the value internally; React doesn’t track every change.

      Code Complexity
      Controlled: More code, but predictable and easier to debug.
      Uncontrolled: Less code, but less predictable and harder to maintain.

      Use Cases
      Controlled: Preferred for most forms where validation, dynamic updates, or controlled behavior is needed.
      Uncontrolled: Useful for quick forms, simple inputs, or when you don’t need React to manage the state.

5. Difference between state and props in React?
Ans = Difference Between State and Props in React are:

      Definition
      State: A built‑in object that stores data inside a component.
      Props: Short for “properties,” they are inputs passed from parent to child components.

      Mutability
      State: Mutable — can be changed using setState (class) or useState (functional).
      Props: Immutable — cannot be modified by the child component; read‑only.

      Ownership
      State: Owned and managed by the component itself.
      Props: Owned by the parent and passed down to child components.
      
      Usage
      State: Used for data that changes over time (user input, toggles, counters).
      Props: Used to pass data and functions between components.

      Updates
      State: Updates trigger re‑render of the component.
      Props: Changes in props (from parent) also trigger re‑render of the child.

6. What is the difference between useMemo and useCallback?
Ans = Difference Between useMemo and useCallback:

      Purpose
      useMemo: Memoizes a value (result of a computation).
      useCallback: Memoizes a function (so its identity doesn’t change).
      
      Return Type
      useMemo: Returns the computed value.
      useCallback: Returns the function itself.

      Use Cases
      useMemo: Optimize expensive calculations (e.g., filtering, sorting, math).
      useCallback: Prevent unnecessary re‑creation of functions passed as props to child components.

      Dependencies
      Both accept a dependency array.
      useMemo: Recomputes the value only when dependencies change.
      useCallback: Recreates the function only when dependencies change.

      Performance Benefit
      useMemo: Saves CPU cycles by caching results.
      useCallback: Saves memory/re‑renders by keeping function identity stable.

7. What are React keys and why are they important?
Ans = In react key are used when rendering lists. Keys give each element a stable identity So, React can match old and new elements during the reconciliation process. 
      Without keys, React may reuse DOM nodes incorrectly. Keys help React know which items stayed the same, which changed, and which were removed.
      Important: Avoid using array indices as keys unless the list is static and never reordered.
      Keys must be stable — they should not change between renders.

8. Difference between React.Fragment and a div wrapper?
Ans = Difference Between React.Fragment and a div Wrapper

      Extra DOM Node
      React.Fragment: Does not add an extra DOM node.
      div: Adds an extra <div> element to the DOM.

      Clean DOM Structure
      React.Fragment: Keeps the DOM clean and minimal.
      div: Can lead to unnecessary nesting and “div soup.”

      Styling & Layout
      React.Fragment: Cannot have CSS classes, IDs, or styles because it doesn’t render a real element.
      div: Can be styled directly with classes, IDs, or inline styles.

      Use Case
      React.Fragment: Best when you just need to group multiple children without affecting layout or styling.
      div: Best when you need a real container element for styling, layout, or semantic structure.

9. What is the difference between React virtual DOM and real DOM?
Ans = Difference Between Virtual DOM and Real DOM are:

      Definition
      Real DOM: The actual Document Object Model rendered and managed by the browser.
      Virtual DOM: A lightweight, in‑memory representation of the real DOM maintained by React.

      Update Speed
      Real DOM: Updates are slow because every change triggers reflow/repaint of the entire UI.
      Virtual DOM: Updates are fast because React calculates diffs and only applies minimal changes.

      Performance
      Real DOM: Inefficient for frequent updates; large UIs can lag.
      Virtual DOM: Optimized for dynamic UIs; reduces direct manipulation of the real DOM.

      Re-rendering
      Real DOM: Entire UI may re-render when a change occurs.
      Virtual DOM: Only the changed nodes are updated after React’s diffing algorithm.

      Developer Interaction
      Real DOM: Developers manipulate it directly with vanilla JS (document.getElementById, etc.).
      Virtual DOM: Developers work with React components; React handles DOM updates internally.

      Memory Usage
      Real DOM: No extra memory overhead beyond the actual DOM tree.
      Virtual DOM: Requires additional memory to maintain the virtual copy.

10. Difference between Context API and Redux?
Ans = Difference between Context API and Redux are:

      Type
      Context API → Built‑in React feature.
      Redux → External library for state management.

      Setup Complexity
      Context API → Minimal setup (createContext, Provider, useContext).
      Redux → More boilerplate (Store, Actions, Reducers, Middleware).

      Best Use Cases
      Context API → Avoiding prop drilling, sharing simple global state (theme, auth, language).
      Redux → Large apps with complex state changes, multiple interactions, and async logic.

      State Management
      Context API → Provides global context but no strict structure.
      Redux → Centralized store with predictable state transitions via reducers.

      Performance
      Context API → Can cause unnecessary re‑renders if many components consume the same context.
      Redux → Optimized with reducers and middleware; better for large‑scale performance.

      Debugging Tools
      Context API → Limited (React DevTools only).
      Redux → Powerful Redux DevTools (time‑travel debugging, state inspection).

      Middleware Support
      Context API → Not available.
      Redux → Supports middleware (Redux Thunk, Saga) for async operations.

      Learning Curve
      Context API → Easy to learn, minimal boilerplate.
      Redux → Steeper learning curve, requires understanding of actions/reducers.

      Community & Ecosystem
      Context API → Smaller, React‑only.
      Redux → Large ecosystem with plugins, middleware, and integrations.

11. Difference between lazy loading and code splitting?
Ans =  Difference between lazy loading and code splitting are:

      Purpose
      Lazy Loading → Delays loading until needed.(load pieces only when needed.)
      Code Splitting → Divides code into smaller bundles.(cutting your app into smaller pieces.)

      Focus
      Lazy Loading → Focuses on when resources are loaded.
      Code Splitting → Focuses on how resources are organized and delivered.

      Implementation
      Lazy Loading → Often implemented with dynamic imports (import()), React’s React.lazy, or image/data loading strategies.
      Code Splitting → Achieved using bundlers like Webpack, Rollup, or Parcel.

      Performance Benefit
      Lazy Loading → Reduces initial load time by skipping unused parts.
      Code Splitting → Prevents one giant bundle, making downloads smaller and faster.

      Relationship
      Lazy Loading → Usually relies on code splitting under the hood (because you need separate chunks to load later).
      Code Splitting → Can exist without lazy loading (just splitting bundles but still loading them all upfront).

      Use Case
      Lazy Loading → Best for rarely used features (admin panel, settings page, large images).
      Code Splitting → Best for structuring large apps into manageable chunks.

12. What is the difference between React Router v5 and v6?
Ans = Differences Between React Router v5 and v6

      Route Matching
      v5 → Uses <Switch> to render the first matching route.
      v6 → Uses <Routes> which always matches exactly one route and is more predictable.

      Route Declaration
      v5 → <Route path="/home" component={Home} />
      v6 → <Route path="/home" element={<Home />} /> (uses element instead of component).

      Nested Routes
      v5 → More manual setup; often requires multiple <Route> definitions.
      v6 → Built‑in support for nested routes with cleaner syntax.

      Hooks
      v5 → Limited hooks (useHistory, useLocation).
      v6 → Modern hooks (useNavigate, useParams, useRoutes) that simplify navigation and route handling.

      Redirects
      v5 → Uses <Redirect> component.
      v6 → Redirects are handled with <Navigate> element.

      Bundle Size & Performance
      v5 → Larger and less optimized.
      v6 → Smaller, faster, and optimized for modern React.

      Default Behavior
      v5 → Routes are matched inclusively (multiple routes can match).
      v6 → Routes are matched exclusively (only one route matches).

      Upgrade Path
      v5 → Widely used but now legacy.
      v6 → Actively maintained, recommended for new projects, with a compatibility package for gradual upgrades.

13. Difference between useState and useReducer?
Ans = useState:
      Simple hook for managing local state.
      Returns [state, setState].
      Best for small state objects.
      State update are directly (you call setState(newValue)).
      Easy to read, write and minimall boilerplate.
      Great for form input, toggles and counters.

      useReducer:
      Hooks for managing state with a reducer function. 
      Returns [state, dispatch].
      Best for complex state logic with multiple sub-values.
      State update are action basced (dispatch({type: "increment"})).
      More structured, predictable and scalable.
      Great for apps with complex transitions.

14. What is the difference between SSR(Server Side Rendering) and CSR(Client Side Rendering) in React?
Ans = Server-Side Rendering(SSR):
      Rendering happen on the server before sending HTML to the browser.
      Faster initial load - user sees content immediately.
      Better SEO - search engines can crawl full html.
      Requires hydration (React attaches event listeners after HTML loads). 
      More complex setup (needs frameworks like Next.js, server infrastructure).
      Best for content‑heavy apps (blogs, e‑commerce, news sites).

      Client-Side Rendering(CSR):
      Rendering happens entirely in the browser using JavaScript.
      Slower initial loads - blank page untill the JavaScript loads.      
      Weaker SEO - crawlers may struggle.
      Navigation between pages is faster and smoother (no full reloads).
      Simpler setup (just React + bundler, no server rendering).
      Best for highly interactive apps (dashboards, SPAs).

15. Difference between hydration and rendering in React?
Ans = Rendering:
      Reacts builds the DOM tree from your components.
      Happen in the Client Side Rendering or during updates when state/props changes.
      Produces the UI from scratch in the browser.
      User sees content only after JavaScript runs.
      Common in single-page application 

      Hydration:
      React attaches its event listeners and internal logics to already existing HTML.
      Happen in the Server Side Rendering after the server send the pre-built HTML.
      Makes the static html page interactive.
      User sees content immediately then react "hydrates" it.
      Common in SSR frameworks like Next.js.


## Performance, Security & Best Practices ##

1. How do you optimize frontend performance?
Ans = 1. Minimize file size: Compress images, CSS and JS so pages load faster.
      2. Use Caching: Store data in the browser so it does not reload everything each time.
      3. Lazy Loading: Load heavy things(like images or videos) only when the user scroll to them.
      4. Code Splitting: Break big javascript bundles into smaller parts so only what's needed loads first.
      5. Reduce unnecessary re-renders: In React use memo, useCallback and useMemo wisely.
      6. Efficient DOM updates: Avoid heavy operations and keep the DOM tree light.
      7. Preload important resources: Load critical CSS/JS early so the page feels faster.

2. Difference between lazy loading and preloading?
Ans = Lazy loading:
      Loads resources later(on demand).
      Save bandwidth and speed up inital page load.
      User may see a delay when resources first appears.
      Best for heavy images, videos or components.

      Preloading:
      Loads resources earlier(in advance).
      Reduce wait time when the resource is needed.     
      User sees instant response because resource is already loaded.
      Best for critical assets like fonts, CSS or scripts needed soon.

3. What is critical CSS and why is it important?
Ans = Critical Css is the small part of css needed to style the first visible part of a webpage. Instead of loading the entire css file first, we put important
      css directly inside the html so the page looks styled immediately. The rest of the css loads later in the background.
      Importance: 
      1. User see a styled page immediately.
      2. Better User experience.
      3. Improves SEO: search engines prefer fast website.
      4. Large css files can block rendering, critical css avoid this by prioritizing only what is needed.

4. Difference between HTTP/1.1, HTTP/2, and HTTP/3?
Ans = HTTP/1.1:
      One request at a time.
      Data is sent as plain text over TCP.
      Slow, blocking issues.
      Old, still used in some places.

      HTTP/2:
      Multiple requests at once.
      Data is sent in binary format over TCP.
      Faster, no blocking, compressed headers.
      Commonly used now.

      HTTP/3:
      Multiple requests + faster setup.
      Data is also sent in binary form over QUIC(UDP).
      Fastest, works better on poor networks.
      Growing adoption(Google, Facebook and Cloudfare already used it).

5. How to prevent XSS attacks in frontend?
Ans = Steps to prevent the XSS attack are:
      1. Escape user input → Treat everything users type as text, not code.
         Example: Show <script> as plain text instead of running it.

      2. Sanitize input → Clean user data before showing it (remove dangerous tags/scripts).

      3. Use safe methods in React → React automatically escapes values, so don’t bypass it with dangerouslySetInnerHTML.

      4. Avoid unsafe DOM updates → Don’t use innerHTML or document.write with user data. Use textContent instead.

      5. Content Security Policy (CSP) → Add browser rules that block unknown scripts. 

6. What is CORS and how does it work?
Ans = CORS is security feature built in browser. It controls how a website can request resources from another domain. Without CORS a site could secertly fetcht data from 
      another site and misuse it.

Working of the CORS:
      1. Browser sends a request → When your frontend tries to fetch data from another domain, the browser checks if it’s allowed.

      2. Server responds with headers → The other domain’s server must include special headers like: 
         (Access-Control-Allow-Origin: https://example.com)
         This tells the browser: “Yes, I allow this site to access my data.”

      3. Browser enforces rules → If the headers are missing or don’t match, the browser blocks the request.

      4. Preflight requests (OPTIONS) → For sensitive requests (like POST with custom headers), the browser first sends a small “preflight” 
         check to ask the server if it’s safe.

Importance of CORS are:
      1. Protects users from malicious sites stealing data.
      2. Lets developers safely share APIs between trusted websites.
      3. Keeps the web secure while still allowing controlled data sharing.

7. Difference between cache-control and expires header?
Ans = Expires:
      Tells the browser a "fixed date/time" when the resource (like CSS, JS, image) should be considered “stale.”
      Example: Expires: Wed, 10 Feb 2026 19:00:00 GMT
      After this date/time, the browser must re-fetch the resource from the server.
      Limitation: Works with absolute time → if server/client clocks are wrong, caching may break.
      Older, less used today.

      Cache-Control:
      Gives flexible rules for caching using "relative time or policies".
      Example: Cache-Control: max-age=3600
      More powerful: supports options like no-cache, no-store, public, private.
      Preferred over Expires because it’s more reliable and modern.
      Modern, widely used, overrides "Expires" if both are present.

8. What is a Progressive Web App (PWA), what is a Service Worker, and how do they work together to improve the user experience?
Ans = A Progressive Web App(PWA) is basically a website that feels and works like a mobile app.
      1. You can install it on your phone or desktop.
      2. It loads fast, work offline, and can send push notification.
      3. PWAs combine the reach of websites with the experience of apps.

      Service Worker: A Service Worker is a background script that power many of the  special features of a PWA.
      1. It runs separately form the webpage.
      2. It can cache files, control network requests and send push notification.
      3. It is the engine that make the PWAs feel app like.

      Here is how they work together:
      Service worker is the key technology behind PWA.
      Exmaple:
      You open a shopping PWA → the service worker saves product pages, images, and scripts in cache.
      Next time you open it → it loads instantly from cache (fast).
      If you lose internet → it still shows cached products (offline support).
      It can also send you a push notification like “Your order is shipped!” even when the app isn’t open.

9. What do you mean by SSG?
Ans = SSR (Server‑Side Rendering):
      In SSR, the server builds the HTML page fresh for every request.
      The server sends the complete HTML to the browser, and then also sends the JavaScript bundle so the page becomes interactive.
      This gives fast first load and good SEO, but the server has to do more work each time a user visits, which can be heavy under high traffic.

      SSG(Static Site Generation): 
      To reduce the server’s workload, SSG was introduced.
      In SSG, the pages are pre‑built into static HTML files at build time (before deployment).
      When a user visits, the server simply serves the ready‑made HTML — no need to generate it again.
      Along with the HTML, the JavaScript bundle is also pre‑built and sent to the browser.
      The browser first shows the static HTML instantly (fast load), then runs the JavaScript to make the page interactive (buttons, forms, animations, etc.).
      This makes SSG super fast, scalable, and efficient, especially for sites where content doesn’t change often (blogs, docs, portfolios).

10. Difference between CSR, SSR, and SSG in frontend?
Ans = CSR(Client Side Rendering):
      First load is slow because the browser gets blank HTML and must run JavaScript to build the page.
      SEO is weak because search engines may not see content until JavaScript runs.
      Server does less work (just sends blank HTML + JS).
      Best for interactive apps (dashboards, SPAs).

      SSR(Server Side Rendering):
      First load is fast because the server sends complete HTML, so the browser shows content immediately.
      SEO is strong because HTML is ready when the page loads.
      Server does more work (builds HTML fresh for every request).
      Best for dynamic sites (e‑commerce, news).

      SSG(Static Site Generation):
      First load is the fastest because the server serves prebuilt HTML instantly.
      SEO is also strong because prebuilt HTML is complete and easy for crawlers.
      Server does minimal work (just serves prebuilt files).
      Best for static content (blog, docs).

11. What are web components and why use them?
Ans = Normally the website is built with HTML tag like <div>, <button> etc. But sometimes you want your own special tag that does something unique.
      Web Component let you create custom HTML elements (like <user-card> or <app-button>). These custom element behave like normall tag but with your own
      design and logic. 
      They are built using three main parts:
      Custom Elements → define your own HTML tags.
      Shadow DOM → encapsulates styles and markup so they don’t leak or get affected by outside CSS.      
      HTML Templates → reusable chunks of HTML that can be cloned and used inside components

      Example:
      //html code
      <user-card></user-card>
      //js code
      class UserCard extends HTMLElement {
        constructor() {
          super();
          // Attach shadow DOM
          const shadow = this.attachShadow({ mode: 'open' });
          shadow.innerHTML = `
            <style>
              .card { border: 1px solid #ccc; padding: 10px; }
              button { background: blue; color: white; }
            </style>
            <div class="card">
              <p>Name: Varsha</p>
              <button>Follow</button>
            </div>
          `;
        }
      }
      // Register the custom element
      customElements.define('user-card', UserCard);

Why Use Web Component:
      1. Reusability: Build once use everywher. Example: A <user-card> component showing a profile can be reused across page.
      2. Isolation: Style and code inside the component don't mess with the rest of your site(thanks to shadow dom).
      3. Consistency: Same look and behavior wherever you use it.
      4. Works Everywhere: They are browser standards, so they work with plain HTML, or framework like React, Angular, Vue.

12. How do you optimize the loading time of a web page?
Ans = Ways to Optimize Web Page Loading Time are:
      1. Minimize HTTP Requests: Combine CSS/JS files where possible.
      2. Compress Files: Compress and minify CSS, JavaScript and HTML files so the browser downloads the files faster.
      3. Load script smartly: Use async or defer so JavaScript does not block the page from showing.
      4. Cache Content: Let the browser save files so returning visitors dont re-download everything.
      5. Use a CDN (Content Delivery Network): Deliver files from servers closer to the user for faster access.
      6. Optimize fonts: Use fewer font styles and weights, and apply font-display: swap; so text shows quickly.
      7. Efficient code and DOM updates: Avoid unnecessary re-renders, heavy loops, or too many DOM manipulations.

      Importance of Optimize Loading time are:
      1. Faster website = Better user experience.
      2. Improves SEO.
      3. Reduce bounce rate.
      4. Saves bandwidth and server costs.

13. What is the purpose of bundling and minification in web development?
Ans = Bundling: Combine multiple files (like many CSS or JavaScript files) into one single file. Example: Instead of loading style1.css, style2.css you 
      bundle them into style.css/
      Importance: 
      1. Fewer HTTP requests: browser does not need to fetch dozens of small files.
      2. Easier to manage and deliver resources.

      Minification: Remove unnecessary characters (spaces, comments, line breaks) from code without changing how it works.
      Importance:
      1. Smaller file size: Faster download.
      2. Improves performance.

14. How can you reduce the number of HTTP requests on a web page?
Ans = Ways to Reduce HTTP Requests are:
      1. Combine Files: Merge multiple CSS, JavaScript files into one. So, instead of loading 10 small files, load 1 bigger file.
      2. Inline Critical CSS: Put the most important CSS directly in the HTML <head> so the browser doesn’t fetch another file for above‑the‑fold content.
      3. Cache Resources: Let the browser reuse files instead of requesting them again.
      4. Use a Content Delivery Network (CDN): Serve files from servers closer to the user, reducing repeated requests.
      5. Remove Unused Resources: Delete unused CSS, JS, or fonts. Avoid loading libraries if you only use a small part of them.

15. Describe the importance of using a content delivery network (CDN).
Ans = A Content Delivery Network (CDN) is very important in modern web development because it helps websites load faster, stay reliable and handle more users smoothly.
      Importance of Using a CDN are:
      1. Faster Loading Times: CDNs store copies of your website’s static files (images, CSS, JS) on servers around the world.
         When a user visits your site, files are delivered from the server closest to them → reduces latency.
      2. Better Reliability & Availability: If one server goes down, another server in the CDN can serve the content.
         This prevents downtime and keeps your site accessible.
      3. Reduced Bandwidth Costs: Since CDNs cache content, fewer requests hit your origin server.
         This saves bandwidth and reduces hosting costs.
      4. SEO & User Experience: Faster sites rank better on search engines.
         Users are more likely to stay on a site that loads quickly.
      5. Scalability: CDNs can handle sudden traffic spikes (like during sales or viral events) without crashing your main server.

16. What is tree shaking in the context of JavaScript and bundling?
Ans = Tree shaking in JavaScript is a technique used during bundling (with tools like Webpack, Rollup, Parcel) to remove unused code from your final bundle.
      It analyzes your code and “shakes off” parts (functions, variables, modules) that are imported but never actually used.
      The result: smaller, faster bundles because unnecessary code doesn’t get shipped to the browser.

17. How can you optimize images for a web page?
Ans = Ways to Optimize Images for a Web Page are:
      1. Choose the Right Format: Use modern formats like WebP or AVIF (smaller and faster than JPEG/PNG).
         Use SVG for icons and simple graphics (scales perfectly, very lightweight).
      2. Resize Images Properly: Don’t upload a 2000px image if you only need 400px. Match the image size to how it’s displayed on the page.
      3. Compress Images: Use tools like TinyPNG, ImageOptim, or Squoosh to reduce file size without losing quality.
      4. Use Lazy Loading: Load images only when they’re needed (e.g., when the user scrolls to them).
      5. Use Caching & CDN: Store images on a Content Delivery Network (CDN) so they load faster from servers closer to the user.
         Set proper cache headers so browsers don’t re-download unchanged images.


## General Frontend & Tools ##


1. What is the difference between Git merge and Git rebase?
Ans = Git Merge: 
      Combine two branches by creating a new merge commit.
      Preserves full branch history (non-linear).
      Create an extra merge commit.
      Safe for shared/public branches.
      Easy to see when branches were merged.

      Git Rebase: 
      Moves your commits to start on top of another branch, like they were made after the latest changes.
      Creates a clean, linear history.
      No merge commit, rewrites commits. 
      Dangerous on shared branches.
      Harder to see original branching.

2. Difference between package-lock.json and yarn.lock?
Ans = package-lock.json: 
      A file automatically generated by npm.
      Records the exact versions of every installed dependency (and sub-dependency).
      Ensures that anyone who installs the project gets the same dependency tree.
      Helps with reproducible builds and faster installs.
      Uses JSON format.
      Updated when you run npm install.
      Standard for npm projects.

      yarn.lock:
      A file automatically generated by yarn.
      Similar to package-lock.json, it locks down the exact versions of dependencies.
      Ensures consistency across different environments.
      Provides faster installs by caching and parallelizing downloads.
      Uses a custom plain-text format.
      Updated when you run yarn install.
      Standard for Yarn projects especially in large teams.

3. Difference between npm and yarn?
Ans = npm:
      Default package manager that comes bundled with Node.js.
      Generates package-lock.json.
      Earlier versions were slower; modern npm (v7+) has improved a lot.
      Comes pre-installed with Node.js.
      Uses commands like npm install, npm run.
      Added workspace support later.
      Most widely used because it’s the default.
      
      yarn:
      Created by Facebook in 2016 to improve speed and consistency.
      Generates yarn.lock.
      Known for faster installs due to parallel downloads and caching.
      Requires seperate installation.
      Uses commands like yarn install, yarn run.
      Added workspace support earlier. 
      Popular in large projects, especially when npm had performance issues.

4. What is the bundler?
Ans = Deffination: They merge multiple modules and dependencies into fewer files (often just one or a few). Exa: Instead of loading 50 separate JS files, you get one bundle.js.      
      Optimize Code: Remove Unused code(tree shaking). Minify and compress files to reduce size. Transpile modern JS code that older browser can understand.      
      Handle Assets: Process CSS, images, font and other static files. Can inline small assets or optimize large ones.
      Improve Performance: Fewer HTTP request → faster page loads. Smaller file sizes → better user experience.

      Importance of Bundlers:
      Modern apps use modules and external libraries. Browser don't natively understand all of them. Bundler act like a translator + optimizer, 
      making sure everything works together and loads quickly.

5. What is the difference between Webpack and Vite?
Ans = Webpack:
      Bundles everything upfront before serving.
      Slower startup, esecially in large projects.
      Highly configurable but complex.
      Uses its own bundling system.
      Mature, huge plugin ecosystem, widely adopted.
      Best for large-scale apps needing deep customization.
      
      Vite:
      Uses native ES modules in development, bundles inly for production.
      Very fast startup and Hot Module Replacement(HMR).
      Minimal configuration, simpler setup.
      Uses rollup for optimized production builds.
      Newer, growing ecosystem, focused on modern frameworks.
      Best for modern apps where fast development experience is critical.

6. Difference between Tailwind CSS and traditional CSS frameworks?
Ans = Tailwind CSS:
      Utility‑first, build custom designs using small classes.
      Highly flexible, lets you create unique designs easily.  
      
      Traditional CSS framework:
      Component‑based, use pre‑styled UI elements.
      Less flexible, designs often look similar unless heavily customized.
